import React, { useState, useEffect, useRef, useCallback } from "react";
import { createPortal } from "react-dom";
import { ZeptoTypeAhead, ZeptoTypeAheadOption } from "../types";
import { useTypeahead } from "../hooks/useTypeahead";
import { useOutsideClick } from "../hooks/useOutsideClick";
import ArrowRounded from "../icons/arrow-rounded";
import {
  defaultContainerStyles,
  defaultOptionStyles,
  defaultValueStyles,
  defaultActiveOptionStyle,
} from "../styles/typeaheadStyles";
import TypeaheadHeader from "./TypeaheadHeader";

interface TypeaheadProps extends ZeptoTypeAhead {
  inputRef: React.RefObject<HTMLInputElement | HTMLTextAreaElement>;
}

export const Typeahead: React.FC<TypeaheadProps> = ({
  options,
  triggerChar = "/",
  position = "bottom",
  activateMode = "multiple",
  maxVisibleOptions = 5,
  typeAheadContainerStyles,
  typeAheadOptionStyles,
  typeAheadActiveOptionStyle,
  typeAheadOptionValueStyles,
  onSelect,
  searchCallback,
  renderOption,
  renderHeader,
  inputRef,
}) => {
  const [activeIndex, setActiveIndex] = useState(0);
  const [nestedPath, setNestedPath] = useState<ZeptoTypeAheadOption[]>([]);
  const containerRef = useRef<HTMLDivElement>(null);
  const portalRef = useRef<HTMLDivElement | null>(null);

  const {
    isActive: currentIsActive,
    filteredOptions: currentOptions,
    setIsActive: setCurrentIsActive,
    setNestedOptions: setCurrentNestedOptions,
  } = useTypeahead(
    inputRef,
    options,
    triggerChar,
    activateMode,
    searchCallback
  );

  // Get caret coordinates using a more reliable method
  const getCaretCoordinates = useCallback(() => {
    if (!inputRef.current) return { top: 0, left: 0 };

    const input = inputRef.current;

    if (input instanceof HTMLTextAreaElement) {
      // Create a clone of the textarea with exact same styles and dimensions
      const clone = document.createElement("div");

      // Copy all computed styles
      const styles = window.getComputedStyle(input);
      Array.from(styles).forEach((prop) => {
        clone.style.setProperty(prop, styles.getPropertyValue(prop));
      });

      // Match dimensions of the textarea content area exactly
      clone.style.position = "absolute";
      clone.style.top = "0";
      clone.style.left = "0";
      clone.style.visibility = "hidden";
      clone.style.overflow = "hidden";
      clone.style.height = "auto";
      clone.style.width = `${input.clientWidth}px`;
      clone.style.boxSizing = "border-box";

      // Copy padding explicitly
      clone.style.paddingTop = styles.paddingTop;
      clone.style.paddingRight = styles.paddingRight;
      clone.style.paddingBottom = styles.paddingBottom;
      clone.style.paddingLeft = styles.paddingLeft;

      // Copy text-related styles
      clone.style.whiteSpace = styles.whiteSpace;
      clone.style.wordWrap = styles.wordWrap;
      clone.style.lineHeight = styles.lineHeight;
      clone.style.fontFamily = styles.fontFamily;
      clone.style.fontSize = styles.fontSize;
      clone.style.fontWeight = styles.fontWeight;

      // Get text up to cursor position
      const selectionStart = input.selectionStart || 0;
      const textBeforeCursor = input.value.substring(0, selectionStart);

      // Split by newlines and preserve them
      const textWithBreaks = textBeforeCursor.replace(/\n/g, "<br>");
      clone.innerHTML = textWithBreaks;

      // Add a span at the end to represent cursor position
      const cursorSpan = document.createElement("span");
      cursorSpan.textContent = "|";
      cursorSpan.style.display = "inline";
      cursorSpan.style.width = "0";
      cursorSpan.style.overflow = "hidden";
      clone.appendChild(cursorSpan);

      // Add to DOM, get position, then remove
      document.body.appendChild(clone);

      // Get client rect of cursor position
      const cursorRect = cursorSpan.getBoundingClientRect();
      const cloneRect = clone.getBoundingClientRect();

      document.body.removeChild(clone);

      // Apply padding offsets (since the clone might not include them in its position)
      const paddingLeft = parseInt(styles.paddingLeft) || 0;

      // Calculate position relative to input, accounting for scroll
      return {
        left: cursorRect.left - cloneRect.left + paddingLeft,
        top: cursorRect.top - cloneRect.top - input.scrollTop,
      };
    } else {
      // For single-line inputs
      const textBeforeCursor = input.value.substring(
        0,
        input.selectionStart || 0
      );
      const span = document.createElement("span");
      span.style.font = window.getComputedStyle(input).font;
      span.style.position = "absolute";
      span.style.visibility = "hidden";
      span.style.whiteSpace = "pre";
      span.textContent = textBeforeCursor || "";
      document.body.appendChild(span);

      const width = span.getBoundingClientRect().width;
      document.body.removeChild(span);

      // Account for padding and scrolling
      const paddingLeft =
        parseInt(window.getComputedStyle(input).paddingLeft) || 0;

      return {
        left: width + paddingLeft - input.scrollLeft,
        top: 0,
      };
    }
  }, [inputRef]);

  const updatePosition = useCallback(() => {
    if (!containerRef.current || !inputRef.current || !portalRef.current)
      return;

    const container = containerRef.current;
    const input = inputRef.current;
    const inputRect = input.getBoundingClientRect();

    // Keep container invisible until positioned correctly
    container.style.visibility = "hidden";
    container.style.opacity = "0";

    // Calculate container height based on options and max visible
    const optionCount = Math.min(currentOptions.length, maxVisibleOptions);
    const optionHeight = 36; // Estimated height of an option
    const containerHeight = optionCount * optionHeight;
    const containerWidth = container.offsetWidth;

    // Constants for positioning
    const VERTICAL_SPACING = 4;
    const HORIZONTAL_OFFSET = 0;

    // Variables for positioning
    let leftPositionValue = "0px";
    let topPositionValue = "0px";
    let bottomPositionValue = "";

    if (position === "cursor") {
      // Get caret coordinates
      const caretCoords = getCaretCoordinates();

      // Calculate absolute position
      const cursorLeft = inputRect.left + caretCoords.left;
      const cursorTop = inputRect.top + caretCoords.top;

      // Account for line height
      const lineHeight =
        parseInt(window.getComputedStyle(input).lineHeight) ||
        parseInt(window.getComputedStyle(input).fontSize) ||
        16;

      // Check if there's enough space below the cursor
      const spaceBelow = window.innerHeight - (cursorTop + lineHeight);
      const spaceAbove = cursorTop;

      if (
        spaceBelow >= containerHeight + VERTICAL_SPACING ||
        spaceBelow >= spaceAbove
      ) {
        // Position below the cursor if there's enough space or more space than above
        topPositionValue = `${cursorTop + lineHeight + VERTICAL_SPACING}px`;
        bottomPositionValue = "";
      } else {
        // Position above the cursor
        topPositionValue = "";
        bottomPositionValue = `${
          window.innerHeight - cursorTop + VERTICAL_SPACING
        }px`;
      }

      // Determine horizontal position based on available space
      const leftPosition = Math.max(0, cursorLeft - HORIZONTAL_OFFSET);
      const rightOverflow = leftPosition + containerWidth > window.innerWidth;

      if (rightOverflow) {
        // Not enough space to the right, try positioning aligned to the right edge of the screen
        leftPositionValue = `${Math.max(
          0,
          window.innerWidth - containerWidth - 10
        )}px`;
      } else {
        // Enough space, position to the left of cursor
        leftPositionValue = `${leftPosition}px`;
      }
    } else {
      // For top/bottom positioning (relative to the input)
      const spaceAbove = inputRect.top;
      const spaceBelow = window.innerHeight - inputRect.bottom;

      // Determine the best position based on available space
      const effectivePosition =
        (position === "top" &&
          spaceAbove < containerHeight + VERTICAL_SPACING) ||
        (position === "bottom" &&
          spaceBelow < containerHeight + VERTICAL_SPACING)
          ? position === "top"
            ? "bottom"
            : "top"
          : position;

      // Horizontal positioning for input
      const leftPosition = inputRect.left;
      const rightOverflow = leftPosition + containerWidth > window.innerWidth;

      if (rightOverflow) {
        // Align to right edge of input
        leftPositionValue = `${Math.max(
          0,
          inputRect.right - containerWidth
        )}px`;
      } else {
        // Align to left edge of input
        leftPositionValue = `${leftPosition}px`;
      }

      // Vertical positioning - set either top or bottom but not both
      if (effectivePosition === "top") {
        topPositionValue = "";
        bottomPositionValue = `${
          window.innerHeight - inputRect.top + VERTICAL_SPACING
        }px`;
      } else {
        topPositionValue = `${inputRect.bottom + VERTICAL_SPACING}px`;
        bottomPositionValue = "";
      }
    }

    // Apply all positioning at once to prevent jitter
    container.style.left = leftPositionValue;
    container.style.top = topPositionValue;
    container.style.bottom = bottomPositionValue;

    // Make visible after all positioning is done
    // This prevents visible repositioning that causes jitter
    requestAnimationFrame(() => {
      if (container) {
        container.style.visibility = "";
        container.style.opacity = "1";
      }
    });
  }, [
    inputRef,
    position,
    currentOptions.length,
    maxVisibleOptions,
    getCaretCoordinates,
  ]);

  const resetTypeahead = useCallback(() => {
    setCurrentIsActive(false);
    setActiveIndex(0);
    setNestedPath([]);
    setCurrentNestedOptions(options);
  }, [options, setCurrentIsActive, setCurrentNestedOptions]);

  const handleSelect = useCallback(
    (option: ZeptoTypeAheadOption) => {
      if (option.children && option.children.length > 0) {
        setNestedPath((prevPath) => [...prevPath, option]);
        setCurrentNestedOptions(option.children);
        setActiveIndex(0);
      } else {
        if (inputRef.current) {
          const input = inputRef.current;
          const value = input.value;
          const cursorPosition = input.selectionStart || 0;
          const searchStart = value.lastIndexOf(
            triggerChar,
            cursorPosition - 1
          );

          // Replace the trigger character and search text with the selected value
          const newValue =
            value.slice(0, searchStart) +
            (option.value || option.label) +
            value.slice(cursorPosition);
          input.value = newValue;

          // Set cursor position after the inserted value
          const newCursorPosition =
            searchStart + (option.value || option.label).length;
          input.setSelectionRange(newCursorPosition, newCursorPosition);
        }
        onSelect?.(option);
        resetTypeahead();
      }
    },
    [inputRef, onSelect, resetTypeahead, setCurrentNestedOptions, triggerChar]
  );

  const handleBack = useCallback(() => {
    if (nestedPath.length > 0) {
      const newPath = [...nestedPath];
      newPath.pop();

      if (newPath.length === 0) {
        setNestedPath([]);
        setCurrentNestedOptions(options);
      } else {
        setNestedPath(newPath);
        setCurrentNestedOptions(newPath[newPath.length - 1].children || []);
      }
      setActiveIndex(0);
      updatePosition();

      // Clear the search text when going back
      if (inputRef.current) {
        const input = inputRef.current;
        const value = input.value;
        const cursorPosition = input.selectionStart || 0;
        const searchStart = value.lastIndexOf(triggerChar, cursorPosition - 1);
        input.value = value.slice(0, searchStart + 1);
        input.setSelectionRange(searchStart + 1, searchStart + 1);
      }
    }
  }, [
    nestedPath,
    options,
    setCurrentNestedOptions,
    updatePosition,
    inputRef,
    triggerChar,
  ]);

  // Use the new outside click hook
  useOutsideClick(
    [containerRef, inputRef],
    () => resetTypeahead(),
    currentIsActive
  );

  const handleNestedNavigation = useCallback(
    (option: ZeptoTypeAheadOption) => {
      if (option.children && option.children.length > 0) {
        setNestedPath((prevPath) => [...prevPath, option]);
        setCurrentNestedOptions(option.children);
        setActiveIndex(0);
        updatePosition();

        // Clear search characters when navigating to a child category
        if (inputRef.current) {
          const input = inputRef.current;
          const value = input.value;
          const cursorPosition = input.selectionStart || 0;
          const searchStart = value.lastIndexOf(
            triggerChar,
            cursorPosition - 1
          );

          if (searchStart !== -1) {
            // Keep only the trigger character
            input.value = triggerChar;
            input.setSelectionRange(1, 1);
          }
        }
      } else {
        handleSelect(option);
      }
    },
    [
      handleSelect,
      setCurrentNestedOptions,
      updatePosition,
      inputRef,
      triggerChar,
    ]
  );

  const handleClose = useCallback(() => {
    resetTypeahead();
  }, [resetTypeahead]);

  // Create portal container on mount
  useEffect(() => {
    if (!portalRef.current) {
      portalRef.current = document.createElement("div");
      document.body.appendChild(portalRef.current);
    }
    return () => {
      if (portalRef.current) {
        document.body.removeChild(portalRef.current);
        portalRef.current = null;
      }
    };
  }, []);

  // Handle input changes and filtering
  useEffect(() => {
    if (!inputRef.current || !currentIsActive) return;

    const input = inputRef.current;
    const handleInput = () => {
      const value = input.value;
      const cursorPosition = input.selectionStart || 0;

      // If trigger character is removed, close typeahead and reset all state
      if (value.lastIndexOf(triggerChar, cursorPosition) === -1) {
        resetTypeahead();
        setNestedPath([]); // Ensure nested path is cleared
        return;
      }

      const searchStart =
        value.lastIndexOf(triggerChar, cursorPosition - 1) + 1;

      // Check if the trigger character is standalone (preceded by space or start of line)
      const isStandaloneTrigger =
        searchStart === 1 ||
        (searchStart > 1 && /\s/.test(value.charAt(searchStart - 2)));

      if (!isStandaloneTrigger) {
        resetTypeahead();
        setNestedPath([]); // Ensure nested path is cleared
        return;
      }

      const currentSearch = value.slice(searchStart, cursorPosition);

      // Check if there's a space after the trigger character, if so close the typeahead
      if (currentSearch.includes(" ")) {
        resetTypeahead();
        setNestedPath([]); // Ensure nested path is cleared
        return;
      }

      // Reset to level 1 if we're in nested mode and input changes
      if (nestedPath.length > 0) {
        // Only filter current level options when in nested mode
        const filteredNestedOptions =
          nestedPath[nestedPath.length - 1].children?.filter((option) => {
            if (searchCallback) {
              return searchCallback(option.label, currentSearch);
            }
            return option.label
              .toLowerCase()
              .includes(currentSearch.toLowerCase());
          }) || [];

        setCurrentNestedOptions(filteredNestedOptions);

        // Close typeahead if no results found
        if (filteredNestedOptions.length === 0) {
          resetTypeahead();
          setNestedPath([]); // Ensure nested path is cleared
          return;
        }
      } else {
        let filtered;
        // Don't filter if the search text is empty
        if (currentSearch === "") {
          filtered = options;
        } else {
          // Filter options based on search text
          filtered = options.filter((option) => {
            if (searchCallback) {
              return searchCallback(option.label, currentSearch);
            }
            return option.label
              .toLowerCase()
              .includes(currentSearch.toLowerCase());
          });
        }

        setCurrentNestedOptions(filtered);

        // Close typeahead if no results found
        if (filtered.length === 0) {
          resetTypeahead();
          setNestedPath([]); // Ensure nested path is cleared
          return;
        }
      }

      // Update position after input changes
      updatePosition();
    };

    input.addEventListener("input", handleInput);
    return () => input.removeEventListener("input", handleInput);
  }, [
    currentIsActive,
    nestedPath,
    options,
    resetTypeahead,
    searchCallback,
    setCurrentNestedOptions,
    triggerChar,
    updatePosition,
    inputRef,
  ]);

  // Track cursor movement and trigger character
  useEffect(() => {
    if (!inputRef.current) return;

    const input = inputRef.current;
    const handleKeyDown = (e: Event) => {
      const keyEvent = e as KeyboardEvent;
      if (keyEvent.key === triggerChar) {
        // Check if trigger character would be standalone (preceded by space or start of line)
        const value = input.value;
        const cursorPosition = input.selectionStart || 0;

        const isStandaloneTrigger =
          cursorPosition === 0 ||
          (cursorPosition > 0 && /\s/.test(value.charAt(cursorPosition - 1)));

        if (!isStandaloneTrigger) {
          return;
        }

        // Activate typeahead when trigger character is typed
        setCurrentIsActive(true);
        setCurrentNestedOptions(options);

        // We need to wait for the character to be added to the input before positioning
        setTimeout(() => {
          updatePosition();
        }, 0);
      } else if (keyEvent.key === "Escape") {
        resetTypeahead();
      }
    };

    input.addEventListener("keydown", handleKeyDown);
    return () => input.removeEventListener("keydown", handleKeyDown);
  }, [
    triggerChar,
    options,
    setCurrentIsActive,
    setCurrentNestedOptions,
    updatePosition,
    resetTypeahead,
    inputRef,
  ]);

  // Track cursor movement with click and selection but avoid re-rendering on arrow keys
  useEffect(() => {
    if (!inputRef.current || !currentIsActive) return;

    const input = inputRef.current;

    const handleCursorMove = (e: Event) => {
      const keyEvent = e as KeyboardEvent;
      // Only update position for non-arrow key events to prevent blinking
      const isArrowKey =
        keyEvent.key === "ArrowUp" ||
        keyEvent.key === "ArrowDown" ||
        keyEvent.key === "ArrowLeft" ||
        keyEvent.key === "ArrowRight";

      if (e.type !== "keyup" || !isArrowKey) {
        updatePosition();
      }
    };

    // Track all events that might move the cursor
    input.addEventListener("click", handleCursorMove);
    input.addEventListener("keyup", handleCursorMove);
    input.addEventListener("mouseup", handleCursorMove);

    return () => {
      input.removeEventListener("click", handleCursorMove);
      input.removeEventListener("keyup", handleCursorMove);
      input.removeEventListener("mouseup", handleCursorMove);
    };
  }, [currentIsActive, updatePosition, inputRef]);

  // Update keyboard navigation to use just Alt/Option key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!currentIsActive || !currentOptions.length) return;

      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          setActiveIndex((prev) => (prev + 1) % currentOptions.length);
          break;
        case "ArrowUp":
          e.preventDefault();
          setActiveIndex(
            (prev) => (prev - 1 + currentOptions.length) % currentOptions.length
          );
          break;
        case "Enter":
          e.preventDefault();
          handleSelect(currentOptions[activeIndex]);
          break;
        case "Escape":
          e.preventDefault();
          resetTypeahead();
          break;
        case "Alt":
          e.preventDefault();
          handleBack();
          break;
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [
    currentIsActive,
    currentOptions,
    activeIndex,
    handleSelect,
    resetTypeahead,
    handleBack,
  ]);

  useEffect(() => {
    if (currentIsActive) {
      updatePosition();
      window.addEventListener("resize", updatePosition);
      window.addEventListener("scroll", updatePosition);
      return () => {
        window.removeEventListener("resize", updatePosition);
        window.removeEventListener("scroll", updatePosition);
      };
    }
  }, [currentIsActive, updatePosition]);

  if (!currentIsActive || !portalRef.current || !currentOptions.length)
    return null;

  return createPortal(
    <div
      ref={containerRef}
      style={{
        position: "fixed",
        zIndex: 9999,
        visibility: "hidden",
        maxHeight: `${maxVisibleOptions * 36}px`,
        overflow: "auto",
        ...defaultContainerStyles,
        width: "360px",
        ...typeAheadContainerStyles,
        animation: "typeaheadFadeIn 0.18s ease-out forwards",
        transition: "opacity 0.18s ease-out, transform 0.18s ease-out",
        transform: "translateY(0)",
      }}
    >
      <style>
        {`
          @keyframes typeaheadFadeIn {
            0% {
              opacity: 0;
              transform: translateY(-8px);
            }
            100% {
              opacity: 1;
              transform: translateY(0);
            }
          }
        `}
      </style>

      {renderHeader ? (
        renderHeader({
          onClose: handleClose,
          onBack: handleBack,
          currentCategory: nestedPath[nestedPath.length - 1],
          nestedPath,
        })
      ) : (
        <TypeaheadHeader
          onClose={handleClose}
          onBack={handleBack}
          currentCategory={nestedPath[nestedPath.length - 1]}
          nestedPath={nestedPath}
        />
      )}

      {currentOptions.map((option, index) => {
        const isActive = index === activeIndex;

        if (renderOption) {
          return renderOption({
            option,
            isActive,
            onClick: () => {
              if (option.children && option.children.length > 0) {
                handleNestedNavigation(option);
              } else {
                handleSelect(option);
              }
            },
          });
        }

        return (
          <div
            key={option.label}
            style={{
              ...defaultOptionStyles,
              ...(isActive ? defaultActiveOptionStyle : {}),
              ...typeAheadOptionStyles,
              ...(isActive ? typeAheadActiveOptionStyle : {}),
            }}
            onMouseEnter={() => setActiveIndex(index)}
            onClick={() => {
              if (option.children && option.children.length > 0) {
                handleNestedNavigation(option);
              } else {
                handleSelect(option);
              }
            }}
          >
            <div
              style={{ display: "flex", flexDirection: "column", gap: "2px" }}
            >
              <span style={{ color: "#101418" }}>{option.label}</span>
              {option.description && (
                <span
                  style={{
                    ...defaultValueStyles,
                    ...typeAheadOptionValueStyles,
                  }}
                >
                  {option.description}
                </span>
              )}
            </div>
            {option.children && option.children.length > 0 && <ArrowRounded />}
          </div>
        );
      })}
    </div>,
    portalRef.current
  );
};
